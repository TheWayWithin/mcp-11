/**
 * Environment Configuration Manager - Handles .env.mcp integration
 */

import * as fs from 'fs-extra';
import * as path from 'path';
import * as os from 'os';
import { ConfigTemplate } from '../types/index';
import { MCP_SERVER_REGISTRY, getServersWithEnvVars } from './mcp-registry';

export class EnvironmentManager {
  private envPath: string;
  private backupPath: string;

  constructor(envPath?: string) {
    this.envPath = envPath || this.findExistingEnvFile() || path.join(os.homedir(), '.env.mcp');
    this.backupPath = `${this.envPath}.backup`;
  }

  /**
   * Find existing .env.mcp file in common locations
   */
  private findExistingEnvFile(): string | null {
    const commonPaths = [
      path.join(os.homedir(), '.env.mcp'),
      path.join(os.homedir(), 'BusinessProjects', 'Agents-11 Business', '.env.mcp'),
      path.join(process.cwd(), '.env.mcp'),
      path.join(process.cwd(), '..', '.env.mcp')
    ];

    for (const envPath of commonPaths) {
      if (fs.existsSync(envPath)) {
        return envPath;
      }
    }

    return null;
  }

  /**
   * Load existing environment configuration
   */
  async loadEnvConfig(): Promise<Record<string, string>> {
    if (!await fs.pathExists(this.envPath)) {
      return {};
    }

    const content = await fs.readFile(this.envPath, 'utf-8');
    const config: Record<string, string> = {};

    // Parse .env format
    const lines = content.split('\n');
    for (const line of lines) {
      const trimmed = line.trim();
      if (trimmed && !trimmed.startsWith('#')) {
        const [key, ...valueParts] = trimmed.split('=');
        if (key && valueParts.length > 0) {
          const value = valueParts.join('=').trim();
          // Remove quotes if present
          config[key.trim()] = value.replace(/^["']|["']$/g, '');
        }
      }
    }

    return config;
  }

  /**
   * Save environment configuration
   */
  async saveEnvConfig(config: Record<string, string>): Promise<void> {
    // Create backup if file exists
    if (await fs.pathExists(this.envPath)) {
      await fs.copy(this.envPath, this.backupPath);
    }

    const lines: string[] = [
      '# MCP Environment Variables',
      '# Generated by MCP-11 Universal Utility Library',
      '# Copy this file to .env and fill in your actual API keys',
      ''
    ];

    // Group variables by server
    const serverGroups = this.groupEnvVarsByServer(config);
    
    for (const [serverName, vars] of Object.entries(serverGroups)) {
      lines.push(`# ${serverName} Configuration`);
      for (const [key, value] of Object.entries(vars)) {
        lines.push(`${key}=${value}`);
      }
      lines.push('');
    }

    await fs.writeFile(this.envPath, lines.join('\n'));
  }

  /**
   * Generate configuration templates for all MCP servers
   */
  generateConfigTemplates(): ConfigTemplate[] {
    const templates: ConfigTemplate[] = [];
    const serversWithEnv = getServersWithEnvVars();

    for (const server of serversWithEnv) {
      if (!server.requiredEnvVars || server.requiredEnvVars.length === 0) {
        continue;
      }

      const envVars: Record<string, string> = {};
      
      for (const envVar of server.requiredEnvVars) {
        envVars[envVar] = this.generatePlaceholder(envVar);
      }

      templates.push({
        server: server.name,
        envVars,
        description: server.description,
        required: !server.optional
      });
    }

    return templates;
  }

  /**
   * Validate environment configuration
   */
  async validateEnvConfig(): Promise<{ 
    valid: boolean; 
    missing: string[]; 
    suggestions: Record<string, string> 
  }> {
    const config = await this.loadEnvConfig();
    const missing: string[] = [];
    const suggestions: Record<string, string> = {};

    const serversWithEnv = getServersWithEnvVars();
    
    for (const server of serversWithEnv) {
      if (!server.requiredEnvVars) continue;

      for (const envVar of server.requiredEnvVars) {
        if (!config[envVar] || this.isPlaceholder(config[envVar])) {
          missing.push(envVar);
          suggestions[envVar] = this.generateSuggestion(envVar);
        }
      }
    }

    return {
      valid: missing.length === 0,
      missing,
      suggestions
    };
  }

  /**
   * Merge existing config with new templates
   */
  async mergeWithExisting(templates: ConfigTemplate[]): Promise<Record<string, string>> {
    const existing = await this.loadEnvConfig();
    const merged: Record<string, string> = { ...existing };

    for (const template of templates) {
      for (const [key, placeholder] of Object.entries(template.envVars)) {
        // Only add if key doesn't exist or has placeholder value
        if (!merged[key] || this.isPlaceholder(merged[key])) {
          merged[key] = existing[key] || placeholder;
        }
      }
    }

    return merged;
  }

  /**
   * Create .env.mcp if it doesn't exist
   */
  async ensureEnvFile(): Promise<void> {
    if (await fs.pathExists(this.envPath)) {
      return;
    }

    const templates = this.generateConfigTemplates();
    const config = await this.mergeWithExisting(templates);
    await this.saveEnvConfig(config);
  }

  /**
   * Get environment file path
   */
  getEnvPath(): string {
    return this.envPath;
  }

  /**
   * Check if file exists
   */
  async exists(): Promise<boolean> {
    return fs.pathExists(this.envPath);
  }

  /**
   * Restore from backup
   */
  async restoreBackup(): Promise<void> {
    if (await fs.pathExists(this.backupPath)) {
      await fs.copy(this.backupPath, this.envPath);
    }
  }

  /**
   * Generate placeholder value for environment variable
   */
  private generatePlaceholder(envVar: string): string {
    const placeholders: Record<string, string> = {
      'GITHUB_PERSONAL_ACCESS_TOKEN': 'ghp_your_github_token_here',
      'FIRECRAWL_API_KEY': 'your_firecrawl_api_key_here',
      'CONTEXT7_API_KEY': 'your_context7_api_key_here',
      'CONTEXT7_PROJECT_ID': 'your_context7_project_id_here',
      'FIGMA_ACCESS_TOKEN': 'figd_your_figma_token_here',
      'FIGMA_FILE_KEY': 'your_figma_file_key_here',
      'SUPABASE_ACCESS_TOKEN': 'sbp_your_supabase_token_here',
      'SUPABASE_PROJECT_REF': 'your_supabase_project_ref_here',
      'RAILWAY_API_TOKEN': 'your_railway_api_token_here'
    };

    return placeholders[envVar] || `your_${envVar.toLowerCase()}_here`;
  }

  /**
   * Generate suggestion for environment variable
   */
  private generateSuggestion(envVar: string): string {
    const suggestions: Record<string, string> = {
      'GITHUB_PERSONAL_ACCESS_TOKEN': 'Generate at: https://github.com/settings/tokens',
      'FIRECRAWL_API_KEY': 'Get from: https://firecrawl.dev/app/apikeys',
      'CONTEXT7_API_KEY': 'Get from: https://context7.dev/dashboard',
      'CONTEXT7_PROJECT_ID': 'Find in Context7 dashboard project settings',
      'FIGMA_ACCESS_TOKEN': 'Generate at: https://figma.com/developers/api#access-tokens',
      'FIGMA_FILE_KEY': 'Extract from Figma file URL',
      'SUPABASE_ACCESS_TOKEN': 'Get from: https://supabase.com/dashboard/account/tokens',
      'SUPABASE_PROJECT_REF': 'Find in Supabase project settings',
      'RAILWAY_API_TOKEN': 'Get from: https://railway.app/account/tokens'
    };

    return suggestions[envVar] || `Configure ${envVar} with your service credentials`;
  }

  /**
   * Check if value is a placeholder
   */
  private isPlaceholder(value: string): boolean {
    return value.includes('_here') || 
           value.includes('your_') || 
           value === 'your_api_key' ||
           value === '';
  }

  /**
   * Group environment variables by server
   */
  private groupEnvVarsByServer(config: Record<string, string>): Record<string, Record<string, string>> {
    const groups: Record<string, Record<string, string>> = {};
    
    for (const server of MCP_SERVER_REGISTRY) {
      if (!server.requiredEnvVars || server.requiredEnvVars.length === 0) {
        continue;
      }

      const serverVars: Record<string, string> = {};
      
      for (const envVar of server.requiredEnvVars) {
        if (config[envVar]) {
          serverVars[envVar] = config[envVar];
        }
      }

      if (Object.keys(serverVars).length > 0) {
        groups[server.name] = serverVars;
      }
    }

    return groups;
  }
}